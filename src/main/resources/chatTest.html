<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>User ↔ User Chat (Redis History + STOMP)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
        .fade-in { animation: fadeIn .2s ease-in; }
        @keyframes fadeIn { from{opacity:0;transform:translateY(4px)} to{opacity:1;transform:translateY(0)} }
        .sep { position: sticky; top: 6px; z-index: 5; }
    </style>
</head>
<body class="bg-gray-100 text-gray-900 min-h-screen">
<div class="max-w-4xl mx-auto p-4 md:p-8">
    <div class="bg-white rounded-2xl shadow-xl overflow-hidden">
        <div class="bg-blue-600 text-white p-6">
            <h1 class="text-2xl md:text-3xl font-bold">User ↔ User Chat</h1>
            <p class="text-blue-100">Redis-loaded history + Realtime (ticks & reactions)</p>
        </div>

        <div class="p-6 border-b">
            <div class="grid grid-cols-1 md:grid-cols-5 gap-3 items-end">
                <label class="block">
                    <span class="text-sm text-gray-600">API Base</span>
                    <input id="apiBase" class="mt-1 w-full p-3 rounded-lg border focus:ring-2 focus:ring-blue-500"
                           value="http://localhost:8080"/>
                    <small class="text-gray-500">Used for /private/v1/chat/history/page</small>
                </label>
                <label class="block">
                    <span class="text-sm text-gray-600">WS URL</span>
                    <input id="wsUrl" class="mt-1 w-full p-3 rounded-lg border focus:ring-2 focus:ring-blue-500"
                           value="ws://localhost:8080/ws"/>
                    <small class="text-gray-500">We’ll append <code>?uid=&lt;selfId&gt;</code> if missing</small>
                </label>
                <label class="block">
                    <span class="text-sm text-gray-600">Your userId</span>
                    <input id="selfId" class="mt-1 w-full p-3 rounded-lg border focus:ring-2 focus:ring-blue-500" placeholder="e.g. 1"/>
                </label>
                <label class="block">
                    <span class="text-sm text-gray-600">Peer userId</span>
                    <input id="peerId" class="mt-1 w-full p-3 rounded-lg border focus:ring-2 focus:ring-blue-500" placeholder="e.g. 2"/>
                </label>
                <div class="flex gap-2">
                    <button id="connectBtn" class="bg-green-600 hover:bg-green-700 text-white font-semibold px-4 rounded-lg shadow">Connect</button>
                    <button id="disconnectBtn" class="hidden bg-red-600 hover:bg-red-700 text-white font-semibold px-4 rounded-lg shadow">Disconnect</button>
                </div>
            </div>
            <div id="status" class="mt-3 text-sm font-medium text-red-600">Status: Disconnected</div>
        </div>

        <div class="p-6 grid gap-4">
            <div class="flex items-center gap-2">
                <button id="loadOlderBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold px-3 py-1 rounded-lg">Load older</button>
                <span id="pageInfo" class="text-sm text-gray-500"></span>
            </div>

            <div id="feed" class="h-96 overflow-y-auto bg-gray-50 rounded-xl p-4 space-y-2 border"></div>

            <div class="grid grid-cols-1 md:grid-cols-5 gap-3 items-stretch">
        <textarea id="textInput" rows="2" class="md:col-span-4 w-full p-3 rounded-lg border focus:ring-2 focus:ring-blue-500"
                  placeholder="Type a message… (Enter = send, Shift+Enter = newline)"></textarea>
                <button id="sendBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow p-3">Send</button>
            </div>
        </div>
    </div>
</div>

<script>
    /** ====== CONFIG ====== */
    const SUB_BASE  = "/user";            // subscriptions like /user/{selfId}/queue/...
    const DEST_SEND = "/app/chat.send";
    const DEST_ACK  = "/app/chat.ack";
    const DEST_REACT= "/app/chat.react";
    const PAGE_SIZE = 30;

    /** ====== DOM ====== */
    const apiBaseEl = document.getElementById("apiBase");
    const wsUrlEl   = document.getElementById("wsUrl");
    const selfIdEl  = document.getElementById("selfId");
    const peerIdEl  = document.getElementById("peerId");
    const connectBtn= document.getElementById("connectBtn");
    const disconnectBtn = document.getElementById("disconnectBtn");
    const statusEl  = document.getElementById("status");
    const feedEl    = document.getElementById("feed");
    const textInput = document.getElementById("textInput");
    const sendBtn   = document.getElementById("sendBtn");
    const loadOlderBtn = document.getElementById("loadOlderBtn");
    const pageInfo  = document.getElementById("pageInfo");

    /** ====== STATE ====== */
    let stomp = null;
    let selfId = null;
    let peerId = null;
    let oldestTs = null;        // ms of oldest message we have (for beforeTs)
    let newSepInserted = false; // “New messages” separator
    const rank = { SENT:0, DELIVERED:1, READ:2 };
    const EMOJI = ["👍","❤️","😂","😮","😢","😡"];
    const bubbles = new Map();  // key -> { el, ticksEl, sumEl, data }

    /** ====== UTIL ====== */
    function setConnected(on){
      connectBtn.classList.toggle("hidden", on);
      disconnectBtn.classList.toggle("hidden", !on);
      selfIdEl.disabled = on; wsUrlEl.disabled = on; apiBaseEl.disabled = on; peerIdEl.disabled = on;
      statusEl.textContent = on ? "Status: Connected" : "Status: Disconnected";
      statusEl.className = "mt-3 text-sm font-medium " + (on ? "text-green-600":"text-red-600");
    }
    function uuid(){ return (crypto?.randomUUID?.() ?? (Date.now()+"-"+Math.random())); }
    function keyOf(m){ return m.id ?? m.clientMessageId; }
    function parseEpochMaybe(v){
      if (typeof v === "number") return v;
      if (typeof v === "string" && /^\d+$/.test(v)) return parseInt(v, 10);
      return NaN;
    }
    function atMs(m){
      const v = m.createdAt ?? m.timestamp;
      if (!v) return Date.now();
      const maybeEpoch = parseEpochMaybe(v);
      return Number.isNaN(maybeEpoch) ? Date.parse(v) : maybeEpoch;
    }
    function statusLabel(s){ return s==="READ"?"✓✓ read": (s==="DELIVERED"?"✓ delivered":"• sent"); }
    function nearBottom(px=24){ return feedEl.scrollHeight - feedEl.scrollTop - feedEl.clientHeight < px; }
    function appendUid(url, id){
      try{ const u = new URL(url); if(!u.searchParams.get("uid")) u.searchParams.set("uid", id); return u.toString(); }
      catch{ return url + (url.includes("?")?"&":"?") + "uid=" + encodeURIComponent(id); }
    }

    /** ====== RENDER ====== */
    function reactionSummary(map){
      if(!map) return "";
      const out=[]; Object.entries(map).forEach(([emo,c])=> out.push(`${emo} ${c}`));
      return out.join("  ");
    }
    function bubbleHtml(data, mine){
      const when = new Date(atMs(data)).toLocaleString();
      return `
        <div class="group relative max-w-[85%] rounded-2xl px-4 py-2 shadow ${mine?"bg-blue-600 text-white":"bg-white border"}" data-key="${keyOf(data)}">
          <div class="text-xs opacity-75 ${mine?"text-blue-100":"text-gray-500"}">
            ${mine?"You":("User "+data.senderId)} → ${data.recipientId} • ${when}
          </div>
          <div class="whitespace-pre-wrap mt-0.5">${escapeHtml(data.content||"")}</div>
          <div class="ticks absolute -bottom-5 right-2 text-xs ${mine?"text-blue-500":"text-gray-400"}">${statusLabel(data.status||"SENT")}</div>
          <div class="sum absolute bottom-[50%] -left-7 text-xs bg-white border rounded-full px-2">${reactionSummary(data.reactions)}</div>
          <button class="picker absolute -bottom-4 left-2 text-sm bg-white border rounded-full px-2 py-0.5 hidden group-hover:block">😊</button>
        </div>`;
    }
    function escapeHtml(s){ return s.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

    function attachBubbleEvents(div, data){
      const picker = div.querySelector(".picker");
      picker.addEventListener("click", ()=>{
        const existing = div.querySelector(".reaction-picker");
        if(existing) { existing.remove(); return; }
        const p = document.createElement("div");
        p.className = "reaction-picker absolute -bottom-14 right-2 bg-white border rounded-xl shadow p-1 flex space-x-1";
        EMOJI.forEach(e=>{
          const b = document.createElement("button");
          b.className="px-2 py-1 hover:bg-gray-100 rounded"; b.textContent=e;
          b.addEventListener("click", ()=>{ sendReaction(data, e); p.remove(); });
          p.appendChild(b);
        });
        div.appendChild(p);
      });
    }

    function addOne(data, mine, {atTop=false}={}){
      const k = keyOf(data);
      // ✅ Dedupe/update if already rendered
      if (bubbles.has(k)) {
        const ref = bubbles.get(k);
        ref.data = { ...ref.data, ...data };
        ref.ticksEl.textContent = statusLabel(ref.data.status || "SENT");
        if (ref.sumEl && ref.data.reactions) ref.sumEl.textContent = reactionSummary(ref.data.reactions);
        return;
      }

      const wrap = document.createElement("div");
      wrap.className = `w-full flex ${mine ? "justify-end" : "justify-start"} fade-in`;
      wrap.innerHTML = bubbleHtml(data, mine);
      const bubble = wrap.firstElementChild;
      const ticksEl = bubble.querySelector(".ticks");
      const sumEl   = bubble.querySelector(".sum");

      if (atTop) feedEl.prepend(wrap); else feedEl.appendChild(wrap);
      if (!atTop) feedEl.scrollTop = feedEl.scrollHeight;

      bubbles.set(k, { el:bubble, ticksEl, sumEl, data });
      attachBubbleEvents(bubble, data);

      if (!mine) {
        sendAck(data, "DELIVERED");
        if (document.visibilityState === "visible" && window.hasFocus() && String(data.senderId)===String(peerId)) {
          sendAck(data, "READ");
        }
      }
    }

    function ensureNewSeparator(){
      if(newSepInserted) return;
      const sep = document.createElement("div");
      sep.className="sep flex justify-center";
      sep.innerHTML = `<span class="text-xs bg-yellow-200 text-yellow-800 rounded-full px-3 py-1 shadow">New messages</span>`;
      feedEl.appendChild(sep);
      newSepInserted = true;
    }

    /** ====== HISTORY (Redis → DB fallback on server) ====== */
    async function loadHistory({reset=false}={}){
      const base = apiBaseEl.value.trim();
      const url = new URL(base + "/private/v1/chat/history/page");
      url.searchParams.set("currentUserId", selfId);
      url.searchParams.set("targetUserId", peerId);
      url.searchParams.set("limit", PAGE_SIZE);
      if (oldestTs) url.searchParams.set("beforeTs", String(oldestTs));

      try{
        const res = await fetch(url.toString());
        if(!res.ok) throw new Error(res.status + " " + (await res.text()));
        const arr = await res.json(); // server returns NEWEST→OLDEST
        pageInfo.textContent = "";

        if (reset) {
          // Initial load: clear, then render OLDEST→NEWEST and APPEND (keeps chronology stable)
          feedEl.innerHTML=""; bubbles.clear(); newSepInserted=false; oldestTs=null;
          const slice = [...arr].reverse();
          const frag = document.createDocumentFragment();
          slice.forEach(m => {
            const mine = String(m.senderId) === String(selfId);
            // build but don't attach yet
            const k = keyOf(m);
            if (!bubbles.has(k)) {
              const wrap = document.createElement("div");
              wrap.className = `w-full flex ${mine ? "justify-end" : "justify-start"} fade-in`;
              wrap.innerHTML = bubbleHtml(m, mine);
              const bubble = wrap.firstElementChild;
              const ticksEl = bubble.querySelector(".ticks");
              const sumEl   = bubble.querySelector(".sum");
              bubbles.set(k, { el:bubble, ticksEl, sumEl, data:m });
              attachBubbleEvents(bubble, m);
              frag.appendChild(wrap);
            }
            const ts = atMs(m);
            oldestTs = (oldestTs==null) ? ts : Math.min(oldestTs, ts);
          });
          feedEl.appendChild(frag);
          feedEl.scrollTop = feedEl.scrollHeight; // jump to bottom after initial load
        } else {
          // Load older: PREPEND in NEWEST→OLDEST order so that final top→down remains oldest→newest
          const prevHeight = feedEl.scrollHeight;
          arr.forEach(m => {
            const mine = String(m.senderId) === String(selfId);
            addOne(m, mine, { atTop:true }); // prepend each
            const ts = atMs(m);
            oldestTs = (oldestTs==null) ? ts : Math.min(oldestTs, ts);
          });
          // preserve viewport position after prepends
          const delta = feedEl.scrollHeight - prevHeight;
          feedEl.scrollTop += delta;
          if (arr.length === 0) {
            loadOlderBtn.disabled = true;
            pageInfo.textContent = "No older messages.";
          }
        }
        pageInfo.textContent = pageInfo.textContent || `Loaded ${arr.length} (oldestTs=${oldestTs ?? "-"})`;
      }catch(e){
        pageInfo.textContent = "History: " + e.message;
        console.warn("History fetch failed:", e);
      }
    }

    /** ====== LIVE UPDATE HANDLERS ====== */
    function updateStatus(m){
      const ref = bubbles.get(keyOf(m));
      if(!ref) return;
      const oldS = ref.data.status || "SENT";
      const newS = m.status || oldS;
      if(rank[newS] >= rank[oldS]){
        ref.data = { ...ref.data, ...m, status:newS };
        ref.ticksEl.textContent = statusLabel(newS);
      }
      if(m.reactions && ref.sumEl) ref.sumEl.textContent = reactionSummary(m.reactions);
    }
    function updateReactions(m){
      const ref = bubbles.get(keyOf(m));
      if(!ref) return;
      ref.data.reactions = m.reactions;
      if(ref.sumEl) ref.sumEl.textContent = reactionSummary(m.reactions);
    }

    /** ====== SENDER ====== */
    function sendMessage(){
      const content = textInput.value.trim();
      if(!stomp || !selfId || !peerId || !content) return;
      const msg = {
        clientMessageId: uuid(),
        senderId: selfId,
        recipientId: peerId,
        content,
        timestamp: new Date().toISOString()
      };
      const shouldStickBottom = nearBottom();
      stomp.send(DEST_SEND, {}, JSON.stringify(msg));
      textInput.value=""; textInput.focus();
      if(shouldStickBottom) feedEl.scrollTop = feedEl.scrollHeight;
    }
    function sendAck(m, type){
      if(!stomp) return;
      stomp.send(DEST_ACK, {}, JSON.stringify({
        messageId: m.id,
        clientMessageId: m.clientMessageId,
        type,
        actorId: selfId
      }));
    }
    function sendReaction(m, emoji){
      if(!stomp) return;
      stomp.send(DEST_REACT, {}, JSON.stringify({
        messageId: m.id,
        clientMessageId: m.clientMessageId,
        actorId: selfId,
        emoji
      }));
    }

    /** ====== CONNECT ====== */
    connectBtn.addEventListener("click", async ()=>{
      selfId = selfIdEl.value.trim();
      peerId = peerIdEl.value.trim();
      if(!selfId || !peerId){ alert("Enter your userId and peerId"); return; }

      // initial history
      oldestTs = null;
      loadOlderBtn.disabled = false;
      await loadHistory({reset:true});

      // ws (append uid if not present)
      let wsUrl = wsUrlEl.value.trim();
      if(!/\buid=/.test(wsUrl)) wsUrl = appendUid(wsUrl, selfId);
      const socket = new WebSocket(wsUrl);
      stomp = Stomp.over(socket); stomp.debug = null;

      stomp.connect({}, ()=>{
        setConnected(true);

        // messages
        stomp.subscribe(`${SUB_BASE}/${selfId}/queue/chat`, frame=>{
          const m = JSON.parse(frame.body);
          const mine = String(m.senderId) === String(selfId);
          const shouldStick = nearBottom();
          if(!mine && String(m.senderId) !== String(peerId) && !shouldStick){
            ensureNewSeparator();
          }
          addOne(m, mine);
          if(shouldStick) feedEl.scrollTop = feedEl.scrollHeight;
        });

        // status (delivered/read)
        stomp.subscribe(`${SUB_BASE}/${selfId}/queue/chat.status`, frame=>{
          updateStatus(JSON.parse(frame.body));
        });

        // reactions
        stomp.subscribe(`${SUB_BASE}/${selfId}/queue/chat.react`, frame=>{
          updateReactions(JSON.parse(frame.body));
        });

      }, err=>{
        console.error("STOMP error:", err);
        alert("WS connection failed (see console).");
        setConnected(false);
      });
    });

    disconnectBtn.addEventListener("click", ()=>{
      if(stomp){ stomp.disconnect(()=>setConnected(false)); }
    });

    /** ====== UI actions ====== */
    sendBtn.addEventListener("click", sendMessage);
    textInput.addEventListener("keydown", e=>{
      if(e.key==="Enter" && !e.shiftKey){ e.preventDefault(); sendMessage(); }
    });

    loadOlderBtn.addEventListener("click", ()=> loadHistory({reset:false}));

    // mark visible as READ when tab refocuses
    window.addEventListener("focus", ()=>{
      [...bubbles.values()].forEach(({data})=>{
        if(String(data.senderId)!==String(peerId)) return;
        if(data.status==="READ") return;
        sendAck(data, "READ");
      });
    });
</script>
</body>
</html>
